# BookLens2 프로젝트 발표 자료

---

## 1. 프로젝트 개요 및 시연

### 1.1 프로젝트 소개
**BookLens2**는 독서를 즐기는 모든 사람을 위한 종합 독서 관리 플랫폼입니다.
- 개인의 독서 여정을 체계적으로 관리하고 추적
- 독서 후기를 공유하며 커뮤니티와 소통
- 책 정보 검색 및 도서관/서점 위치 확인
- 독서 습관 형성 및 독서 통계 관리

### 1.2 주요 기능 시연

#### 홈페이지
- 히어로 배너: 웹사이트 소개 및 주요 프로모션 슬라이드
- 베스트셀러 섹션: Google Books API를 통한 인기 도서 6권 표시
- 신간 도서 섹션: 최신 출간 도서 4권 추천

#### 마이라이브러리
- **책 추가 기능**
  - ISBN 검색: ISBN 입력으로 책 정보 자동 불러오기
  - 제목/저자 검색: Google Books API를 통한 실시간 검색
  - 수동 입력: 직접 책 정보 입력 가능
  - 책 표지 미리보기

- **독서 진행 관리**
  - 독서 시작/종료 기능
  - 실시간 독서 시간 측정 (타이머)
  - 읽은 페이지 수 입력
  - 진행률 자동 계산 및 시각화
  - 독서 상태 관리 (읽는 중/완독)

- **통계 대시보드**
  - 전체 도서 수, 읽는 중인 책 수, 완독한 책 수
  - 총 독서 시간, 오늘 읽은 시간
  - 내 포스팅 개수

#### 커뮤니티
- 모든 사용자의 독서 후기 표시
- 검색 및 필터링: 책 제목, 저자, 내용, 태그로 검색
- 정렬 옵션: 최신순, 평점순, 오래된순
- 내 포스트만 보기 필터
- 포스팅 작성, 수정, 삭제

#### 지도 서비스
- Google Books API를 통한 책 검색
- 카카오맵 연동으로 도서관/서점 위치 표시
- 책별 재고 정보 확인
- 대출 가능/구매 가능 여부 표시
- 도서관/서점 필터링

#### 갤러리
- Google Books API에서 출판사별 책 가져오기
- Masonry 레이아웃으로 책 표지 표시
- 무한 스크롤 애니메이션
- 장르별, 시리즈별 필터링
- 진행률 요약

---

## 2. 구현 환경 및 기술 스택

### 2.1 개발 환경
- **프레임워크**: React 19.2.0
- **빌드 도구**: Vite 7.2.4 (빠른 개발 환경 및 빌드)
- **라우팅**: React Router DOM 7.10.0
- **스타일링**: Tailwind CSS 3.4.18
- **애니메이션**: GSAP 3.13.0
- **상태 관리**: React Context API

### 2.2 외부 API 연동
- **Google Books API**: 책 정보 검색 및 상세 정보
- **Kakao Map API**: 지도 및 위치 서비스
- **Data4Library API**: 실제 도서관 정보 검색 (선택적)

### 2.3 데이터 저장
- **localStorage**: 클라이언트 사이드 데이터 저장
  - 사용자 인증 정보 (sessionStorage)
  - 마이라이브러리 책 목록
  - 독서 세션 정보
  - 커뮤니티 포스팅

### 2.4 배포
- **Vercel**: 자동 배포 및 호스팅
- **환경 변수**: Vercel 대시보드에서 관리

---

## 3. 설계 과정 및 아키텍처

### 3.1 프로젝트 구조
```
booklens2/
├── src/
│   ├── components/        # 재사용 가능한 컴포넌트
│   │   ├── AddBookModal.jsx
│   │   ├── BookCard.jsx
│   │   ├── ReadingStartModal.jsx
│   │   ├── ReadingEndModal.jsx
│   │   ├── Navbar.jsx
│   │   └── ...
│   ├── pages/            # 페이지 컴포넌트
│   │   ├── HomePage.jsx
│   │   ├── MyLibraryPage.jsx
│   │   ├── CommunityPage.jsx
│   │   ├── MapPage.jsx
│   │   └── ...
│   ├── contexts/         # Context API
│   │   └── AuthContext.jsx
│   ├── lib/              # 유틸리티 및 API 함수
│   │   ├── googleBooksApi.js
│   │   └── utils.js
│   └── App.jsx           # 라우팅 설정
├── public/               # 정적 파일
└── package.json
```

### 3.2 데이터 스키마 설계

#### 사용자 (User)
```javascript
{
  id: number,              // 사용자 고유 ID
  email: string,           // 이메일
  name: string,            // 이름
  createdAt: string        // 가입일
}
```
**저장 위치**: `sessionStorage` (키: `'user'`)

#### 책 (Book)
```javascript
{
  id: number,              // 책 고유 ID
  title: string,           // 제목
  author: string,          // 저자
  publisher: string,       // 출판사
  publishDate: string,     // 발행일
  totalPage: number,       // 총 페이지 수
  readPage: number,        // 읽은 페이지 수
  progress: number,        // 진행률 (0-100)
  status: string,          // 'reading' | 'completed' | 'not_started'
  startDate: string,       // 시작일
  completedDate: string,   // 완독일
  totalReadingTime: number, // 총 독서 시간 (초)
  memo: string,            // 메모
  thumbnail: string,       // 책 표지 URL
  isbn: string            // ISBN
}
```
**저장 위치**: `localStorage` (키: `'myLibraryBooks'`)

#### 독서 세션 (Reading Session)
```javascript
{
  bookId: number,          // 책 ID
  startTime: Date         // 시작 시간
}
```
**저장 위치**: `localStorage` (키: `'readingSession'`)
**특징**: 24시간 이상 지난 세션은 자동 무효화

#### 포스팅 (Posting)
```javascript
{
  id: number,              // 포스팅 고유 ID
  bookId: number,          // 책 ID
  bookTitle: string,       // 책 제목
  bookAuthor: string,      // 저자
  title: string,           // 포스팅 제목
  content: string,         // 내용
  rating: number,          // 평점 (1-5)
  tags: string[],          // 태그 배열
  authorId: number,        // 작성자 ID
  userId: number,          // 사용자 ID
  createdAt: string,       // 작성일
  completedDate: string    // 완독일
}
```
**저장 위치**: `localStorage` (키: `'bookPostings'`)

### 3.3 상태 관리 설계
- **Context API**: 전역 인증 상태 관리 (`AuthContext`)
- **Local State**: 각 페이지별 지역 상태 관리 (useState)
- **localStorage**: 영구 데이터 저장 및 동기화

---

## 4. 핵심 코드 설명

### 4.1 인증 시스템 (AuthContext)
```javascript
// src/contexts/AuthContext.jsx
export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null)
  
  // 세션에서 사용자 정보 로드
  useEffect(() => {
    const sessionUser = sessionStorage.getItem('user')
    if (sessionUser) {
      setUser(JSON.parse(sessionUser))
    }
  }, [])
  
  const login = async (email, password) => {
    // 이메일 형식 검증
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    if (!emailRegex.test(email)) {
      throw new Error('올바른 이메일 형식이 아닙니다.')
    }
    
    // 사용자 데이터 생성 및 저장
    const userData = {
      id: Date.now(),
      email: email,
      name: email.split('@')[0],
      createdAt: new Date().toISOString(),
    }
    sessionStorage.setItem('user', JSON.stringify(userData))
    setUser(userData)
    return userData
  }
  
  // ...
}
```
**특징**:
- sessionStorage 사용으로 브라우저 종료 시 자동 로그아웃
- Context API로 전역 인증 상태 제공
- 에러 핸들링 및 유효성 검사

### 4.2 실시간 독서 타이머 시스템
```javascript
// src/pages/MyLibraryPage.jsx

// 독서 세션 상태
const [readingSession, setReadingSession] = useState(null)
const [currentTime, setCurrentTime] = useState(new Date())

// localStorage에서 독서 세션 로드
useEffect(() => {
  const savedSession = localStorage.getItem('readingSession')
  if (savedSession) {
    const session = JSON.parse(savedSession)
    session.startTime = new Date(session.startTime)
    
    // 24시간 이상 지난 세션 무효화
    const now = new Date()
    const hoursSinceStart = (now - session.startTime) / (1000 * 60 * 60)
    if (hoursSinceStart < 24) {
      setReadingSession(session)
    } else {
      localStorage.removeItem('readingSession')
    }
  }
}, [])

// 실시간 타이머 업데이트 (1초마다)
useEffect(() => {
  if (readingSession) {
    const interval = setInterval(() => {
      setCurrentTime(new Date())
    }, 1000)
    return () => clearInterval(interval)
  }
}, [readingSession])

// 현재 세션 경과 시간 계산
const getCurrentSessionTime = () => {
  if (!readingSession) return 0
  const elapsed = Math.floor((currentTime - readingSession.startTime) / 1000)
  return elapsed
}
```
**특징**:
- 1초마다 실시간 업데이트
- 페이지 새로고침 후에도 세션 복원
- 24시간 이상 지난 세션 자동 무효화
- localStorage에 자동 저장

### 4.3 Google Books API 통합
```javascript
// src/lib/googleBooksApi.js

const GOOGLE_BOOKS_API_KEY = import.meta.env.VITE_GOOGLE_BOOKS_API_KEY
const GOOGLE_BOOKS_API_URL = 'https://www.googleapis.com/books/v1/volumes'

export const searchBookByISBN = async (isbn) => {
  // ISBN에서 하이픈 제거
  const cleanISBN = isbn.replace(/-/g, '')
  
  const response = await fetch(
    `${GOOGLE_BOOKS_API_URL}?q=isbn:${cleanISBN}&key=${GOOGLE_BOOKS_API_KEY}`
  )
  
  const data = await response.json()
  const book = data.items[0].volumeInfo
  
  // 표준화된 책 정보 반환
  return {
    title: book.title || '',
    author: book.authors?.join(', ') || '',
    publisher: book.publisher || '',
    pageCount: book.pageCount || 0,
    thumbnail: book.imageLinks?.thumbnail || '',
    isbn13: book.industryIdentifiers?.find(id => id.type === 'ISBN_13')?.identifier || '',
    // ...
  }
}

export const searchBooks = async (query) => {
  const response = await fetch(
    `${GOOGLE_BOOKS_API_URL}?q=${encodeURIComponent(query)}&key=${GOOGLE_BOOKS_API_KEY}&maxResults=10`
  )
  
  const data = await response.json()
  return data.items.map(item => {
    const book = item.volumeInfo
    return {
      id: item.id,
      title: book.title || '',
      author: book.authors?.join(', ') || '',
      thumbnail: book.imageLinks?.thumbnail || '',
      // ...
    }
  })
}
```
**특징**:
- 환경 변수를 통한 API 키 관리
- ISBN 및 일반 검색 지원
- 에러 핸들링 및 빈 데이터 처리
- 표준화된 데이터 형식 반환

### 4.4 카카오맵 통합 및 지도 마커 관리
```javascript
// src/pages/MapPage.jsx

const mapRef = useRef(null)
const mapInstanceRef = useRef(null)
const markersRef = useRef([])

// 지도 초기화
useEffect(() => {
  const initMap = () => {
    // 스크립트 로드 확인
    if (!window.kakaoMapScriptLoaded) {
      setTimeout(initMap, 200)
      return
    }
    
    // window.kakao.maps.load() 콜백 안에서만 지도 생성
    window.kakao.maps.load(() => {
      const container = mapRef.current
      const options = {
        center: new window.kakao.maps.LatLng(37.5665, 126.9780),
        level: 5
      }
      
      const map = new window.kakao.maps.Map(container, options)
      mapInstanceRef.current = map
      
      // 타일 로드 후 마커 표시
      window.kakao.maps.event.addListener(map, 'tilesloaded', () => {
        displayMarkers(locations, selectedBook)
      })
    })
  }
  
  initMap()
}, [])

// 마커 표시 함수
const displayMarkers = (locationsToShow, currentSelectedBook) => {
  // 기존 마커 제거
  markersRef.current.forEach(marker => {
    if (marker.infoWindow) marker.infoWindow.close()
    marker.setMap(null)
  })
  markersRef.current = []
  
  // 새 마커 생성
  locationsToShow.forEach((location) => {
    const markerImage = new window.kakao.maps.MarkerImage(
      location.type === 'library' 
        ? 'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/marker_red.png'
        : 'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/marker_orange.png',
      new window.kakao.maps.Size(24, 35),
      { offset: new window.kakao.maps.Point(12, 35) }
    )
    
    const marker = new window.kakao.maps.Marker({
      position: new window.kakao.maps.LatLng(location.lat, location.lng),
      image: markerImage,
      map: mapInstanceRef.current
    })
    
    // InfoWindow 생성 및 이벤트 리스너
    const infoWindow = new window.kakao.maps.InfoWindow({
      content: createInfoWindowContent(location, currentSelectedBook),
      removable: true
    })
    
    marker.infoWindow = infoWindow
    window.kakao.maps.event.addListener(marker, 'click', () => {
      // 다른 InfoWindow 닫기
      markersRef.current.forEach(m => {
        if (m !== marker && m.infoWindow) m.infoWindow.close()
      })
      infoWindow.open(mapInstanceRef.current, marker)
    })
    
    markersRef.current.push(marker)
  })
  
  // 모든 마커가 보이도록 지도 범위 조정
  if (locationsToShow.length > 0) {
    const bounds = new window.kakao.maps.LatLngBounds()
    locationsToShow.forEach(location => {
      bounds.extend(new window.kakao.maps.LatLng(location.lat, location.lng))
    })
    mapInstanceRef.current.setBounds(bounds)
  }
}
```
**특징**:
- 비동기 스크립트 로딩 처리
- 마커 참조 관리로 메모리 누수 방지
- InfoWindow 이벤트 관리
- 지도 범위 자동 조정

### 4.5 디바운싱을 적용한 검색 기능
```javascript
// src/pages/MyLibraryPage.jsx

const [searchQuery, setSearchQuery] = useState('')
const [searchResults, setSearchResults] = useState([])

// 디바운싱 적용한 검색
useEffect(() => {
  const searchBooksByQuery = async () => {
    if (!searchQuery.trim()) {
      setSearchResults([])
      return
    }
    
    setIsSearching(true)
    try {
      const results = await searchBooks(searchQuery)
      setSearchResults(results || [])
    } catch (error) {
      console.error('책 검색 오류:', error)
      setSearchResults([])
    } finally {
      setIsSearching(false)
    }
  }
  
  // 500ms 후 검색 실행 (디바운싱)
  const timeoutId = setTimeout(() => {
    searchBooksByQuery()
  }, 500)
  
  return () => clearTimeout(timeoutId)
}, [searchQuery])
```
**특징**:
- 사용자 입력 완료 후 500ms 지연 검색
- 불필요한 API 호출 최소화
- cleanup 함수로 메모리 누수 방지

### 4.6 커뮤니티 포스팅 필터링 및 정렬
```javascript
// src/pages/CommunityPage.jsx

useEffect(() => {
  let filtered = [...postings]
  
  // 내 포스트만 보기 필터
  if (showMyPostsOnly && user) {
    filtered = filtered.filter(posting =>
      posting.authorId === user.id || posting.userId === user.id
    )
  }
  
  // 검색 필터
  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase()
    filtered = filtered.filter(posting =>
      posting.title.toLowerCase().includes(query) ||
      posting.bookTitle.toLowerCase().includes(query) ||
      posting.bookAuthor.toLowerCase().includes(query) ||
      posting.content.toLowerCase().includes(query) ||
      posting.tags.some(tag => tag.toLowerCase().includes(query))
    )
  }
  
  // 정렬
  filtered.sort((a, b) => {
    switch (sortBy) {
      case 'rating':
        return b.rating - a.rating
      case 'oldest':
        return new Date(a.createdAt) - new Date(b.createdAt)
      case 'latest':
      default:
        return new Date(b.createdAt) - new Date(a.createdAt)
    }
  })
  
  setFilteredPostings(filtered)
}, [postings, searchQuery, sortBy, showMyPostsOnly, user])
```
**특징**:
- 다중 조건 필터링
- 실시간 검색 및 정렬
- localStorage 동기화 지원

---

## 5. 디자인 요소

### 5.1 디자인 시스템
- **브랜드 컬러**: 그린 계열 (#22c55e, brand-500 등)
- **그라데이션 배경**: `bg-gradient-to-b from-brand-50 to-white`
- **카드 기반 레이아웃**: 정보의 시각적 구분
- **반응형 디자인**: Tailwind CSS의 responsive 클래스 활용

### 5.2 주요 UI 컴포넌트
- **모달 시스템**: 독서 시작/종료, 책 추가, 포스팅 확인
- **토스트 메시지**: 사용자 피드백
- **프로그레스 바**: 독서 진행률 시각화
- **카드 컴포넌트**: 책 정보, 포스팅 카드
- **네비게이션 바**: 조건부 렌더링 (로그인/회원가입 페이지 제외)

### 5.3 애니메이션
- **GSAP**: 고급 애니메이션 효과
- **Tailwind CSS 애니메이션**: 호버 효과, 전환 애니메이션
- **로딩 스피너**: 비동기 작업 표시

---

## 6. 개발 과정에서 어려웠던 점

### 6.1 카카오맵 API 비동기 로딩 문제
**문제**:
- 카카오맵 SDK가 비동기로 로드되는데, 컴포넌트 마운트 시 SDK가 아직 준비되지 않아 에러 발생
- `window.kakao.maps.load()` 콜백 안에서만 지도 생성 가능

**해결 방법**:
```javascript
// 스크립트 로드 상태 추적
useEffect(() => {
  let retryCount = 0
  const maxRetries = 50
  
  const initMap = () => {
    // 스크립트 로드 확인
    if (!window.kakaoMapScriptLoaded && retryCount < 20) {
      retryCount++
      setTimeout(initMap, 200)
      return
    }
    
    // SDK 초기화 확인
    if (!window.kakao?.maps?.load) {
      if (retryCount < maxRetries) {
        retryCount++
        setTimeout(initMap, 200)
        return
      }
    }
    
    // window.kakao.maps.load() 콜백 안에서만 사용
    window.kakao.maps.load(() => {
      // 지도 생성 코드
    })
  }
  
  initMap()
}, [])
```
**학습 내용**:
- 비동기 스크립트 로딩 시 재시도 로직 필요
- 콜백 기반 API 사용 시 올바른 타이밍에 코드 실행
- 에러 처리 및 사용자 피드백 중요

### 6.2 localStorage 데이터 동기화 문제
**문제**:
- 여러 탭에서 동시에 데이터를 수정할 때 동기화 문제 발생
- 페이지 새로고침 시 데이터 손실 가능성

**해결 방법**:
```javascript
// storage 이벤트 리스너로 다른 탭의 변경 감지
useEffect(() => {
  const loadData = () => {
    const saved = localStorage.getItem('bookPostings')
    if (saved) {
      setPostings(JSON.parse(saved))
    }
  }
  
  loadData()
  
  // 다른 탭에서 변경 시 자동 업데이트
  const handleStorageChange = (e) => {
    if (e.key === 'bookPostings') {
      loadData()
    }
  }
  
  window.addEventListener('storage', handleStorageChange)
  return () => window.removeEventListener('storage', handleStorageChange)
}, [])
```
**학습 내용**:
- `storage` 이벤트는 같은 탭에서는 발생하지 않음 (다른 탭에서만)
- 데이터 변경 시 즉시 localStorage에 저장하여 일관성 유지
- 에러 핸들링으로 잘못된 데이터 구조 방지

### 6.3 독서 세션 관리 및 타임존 문제
**문제**:
- Date 객체를 localStorage에 저장할 때 JSON 직렬화 문제
- 페이지 새로고침 후 세션 복원 시 Date 객체 복원 필요

**해결 방법**:
```javascript
// 세션 저장 시 Date를 ISO 문자열로 변환
localStorage.setItem('readingSession', JSON.stringify({
  bookId: selectedBookId,
  startTime: new Date().toISOString()
}))

// 세션 로드 시 Date 객체로 복원
const savedSession = localStorage.getItem('readingSession')
if (savedSession) {
  const session = JSON.parse(savedSession)
  session.startTime = new Date(session.startTime)
  
  // 24시간 이상 지난 세션 무효화
  const now = new Date()
  const hoursSinceStart = (now - session.startTime) / (1000 * 60 * 60)
  if (hoursSinceStart >= 24) {
    localStorage.removeItem('readingSession')
  } else {
    setReadingSession(session)
  }
}
```
**학습 내용**:
- Date 객체는 JSON으로 직렬화할 수 없으므로 문자열로 변환 필요
- 복원 시 명시적으로 Date 객체로 변환
- 세션 만료 시간 검증 로직 추가

### 6.4 Google Books API 데이터 구조 불일치
**문제**:
- API 응답 구조가 일관적이지 않음
- 일부 필드가 누락될 수 있음

**해결 방법**:
```javascript
// 옵셔널 체이닝과 기본값 사용
const bookInfo = {
  title: book.title || '',
  author: book.authors?.join(', ') || '',
  thumbnail: book.imageLinks?.thumbnail || book.imageLinks?.smallThumbnail || '',
  isbn13: book.industryIdentifiers?.find(id => id.type === 'ISBN_13')?.identifier || '',
  // ...
}
```
**학습 내용**:
- 외부 API 데이터는 항상 검증 필요
- 옵셔널 체이닝(`?.`) 활용
- 기본값 설정으로 안전한 데이터 처리

---

## 7. 특별히 고민한 부분

### 7.1 사용자 경험(UX) 최적화

#### 실시간 독서 타이머
- **고민**: 페이지를 벗어나도 독서 시간이 유지되어야 하는가?
- **결정**: localStorage에 세션 저장, 24시간 이상 지난 세션은 무효화
- **이유**: 실제 독서 패턴을 반영하면서도 악용 방지

#### 검색 디바운싱
- **고민**: 사용자가 타이핑할 때마다 API 호출?
- **결정**: 500ms 디바운싱 적용
- **이유**: 
  - API 호출 최소화로 비용 절감
  - 서버 부하 감소
  - 사용자 경험 향상 (불필요한 로딩 최소화)

#### 진행률 계산 방식
- **고민**: 총 페이지 수가 없을 때 진행률 표시?
- **결정**: 페이지 수가 없으면 수동 진행률 입력 허용
- **이유**: 유연성 확보 및 사용자 편의성

### 7.2 데이터 구조 설계

#### 포스팅과 책의 관계
- **고민**: 포스팅에 책 정보를 중복 저장할지?
- **결정**: 포스팅에 책 정보 중복 저장 (title, author 등)
- **이유**:
  - 책 삭제 후에도 포스팅 정보 유지
  - 검색 성능 향상
  - 데이터 일관성 유지

#### 독서 세션 관리
- **고민**: 여러 책을 동시에 읽는 경우 처리?
- **결정**: 한 번에 하나의 책만 읽기 가능
- **이유**: 
  - 실제 독서 패턴 반영
  - 데이터 정확성 향상
  - UI 단순화

### 7.3 상태 관리 전략

#### Context API vs Redux
- **고민**: 복잡한 상태 관리를 위해 Redux 도입?
- **결정**: Context API로 충분
- **이유**:
  - 프로젝트 규모가 작음
  - 학습 곡선이 낮음
  - 추가 의존성 최소화

#### localStorage vs IndexedDB
- **고민**: 대용량 데이터 저장을 위한 IndexedDB 사용?
- **결정**: localStorage 사용
- **이유**:
  - 현재 데이터 양으로 충분
  - 구현 단순성
  - 브라우저 호환성

---

## 8. 난이도가 높았던 구현 요소

### 8.1 실시간 독서 타이머 시스템

**구현 난이도**: ⭐⭐⭐⭐⭐

**기술적 도전 과제**:
1. **실시간 업데이트와 성능 최적화**
   - 1초마다 상태 업데이트가 전체 컴포넌트 리렌더링 유발
   - 불필요한 리렌더링 최소화 필요

2. **세션 복원 및 만료 처리**
   - 페이지 새로고침 후 세션 유지
   - 24시간 이상 지난 세션 자동 무효화

3. **Date 객체 직렬화/역직렬화**
   - localStorage 저장/복원 시 Date 객체 처리

**구현 코드**:
```javascript
// 실시간 타이머 업데이트
useEffect(() => {
  if (readingSession) {
    const interval = setInterval(() => {
      setCurrentTime(new Date())
    }, 1000)
    return () => clearInterval(interval)
  }
}, [readingSession])

// 현재 세션 경과 시간 계산
const getCurrentSessionTime = () => {
  if (!readingSession) return 0
  const elapsed = Math.floor((currentTime - readingSession.startTime) / 1000)
  return elapsed
}

// 독서 종료 시 시간 누적
const confirmStopReading = (pagesRead) => {
  const sessionDuration = Math.floor(
    (new Date() - readingSession.startTime) / 1000
  )
  
  setBooks(books.map(b => {
    if (b.id === selectedBookId) {
      return {
        ...b,
        readPage: pagesRead,
        progress: calculateProgress(pagesRead, b.totalPage),
        totalReadingTime: (b.totalReadingTime || 0) + sessionDuration,
        status: progress === 100 ? 'completed' : b.status
      }
    }
    return b
  }))
  
  setReadingSession(null)
}
```

**최적화 방법**:
- `useMemo`로 계산된 값 메모이제이션
- 컴포넌트 분리로 리렌더링 범위 축소
- cleanup 함수로 메모리 누수 방지

### 8.2 카카오맵 동적 마커 관리 및 InfoWindow 제어

**구현 난이도**: ⭐⭐⭐⭐

**기술적 도전 과제**:
1. **비동기 스크립트 로딩 처리**
   - SDK 로드 완료 전 지도 생성 시도 방지
   - 재시도 로직 구현

2. **마커 참조 관리**
   - 마커 추가/제거 시 메모리 누수 방지
   - InfoWindow 중복 열림 방지

3. **책별 재고 정보 필터링**
   - 선택한 책의 재고가 있는 위치만 표시
   - 재고 정보를 InfoWindow에 동적 표시

**구현 코드**:
```javascript
// 마커 표시 및 관리
const displayMarkers = (locationsToShow, currentSelectedBook) => {
  // 기존 마커 및 InfoWindow 제거
  markersRef.current.forEach(marker => {
    if (marker.infoWindow) {
      marker.infoWindow.close()
    }
    marker.setMap(null)
  })
  markersRef.current = []
  
  // 새 마커 생성
  locationsToShow.forEach((location) => {
    const inventory = currentSelectedBook 
      ? getInventory(location.id, currentSelectedBook) 
      : null
    
    const marker = new window.kakao.maps.Marker({
      position: new window.kakao.maps.LatLng(location.lat, location.lng),
      image: createMarkerImage(location.type),
      map: mapInstanceRef.current
    })
    
    // InfoWindow 생성 (재고 정보 포함)
    const infoContent = createInfoWindowContent(location, inventory)
    const infoWindow = new window.kakao.maps.InfoWindow({
      content: infoContent,
      removable: true
    })
    
    marker.infoWindow = infoWindow
    
    // 마커 클릭 이벤트
    window.kakao.maps.event.addListener(marker, 'click', () => {
      // 다른 InfoWindow 닫기
      markersRef.current.forEach(m => {
        if (m !== marker && m.infoWindow) {
          m.infoWindow.close()
        }
      })
      // 현재 InfoWindow 열기
      infoWindow.open(mapInstanceRef.current, marker)
    })
    
    markersRef.current.push(marker)
  })
  
  // 지도 범위 조정
  if (locationsToShow.length > 0) {
    const bounds = new window.kakao.maps.LatLngBounds()
    locationsToShow.forEach(location => {
      bounds.extend(new window.kakao.maps.LatLng(location.lat, location.lng))
    })
    mapInstanceRef.current.setBounds(bounds)
  }
}
```

**학습 내용**:
- useRef를 활용한 DOM/객체 참조 관리
- 이벤트 리스너 적절한 cleanup
- 비동기 API와 React 생명주기 통합

### 8.3 Google Books API 통합 및 데이터 표준화

**구현 난이도**: ⭐⭐⭐

**기술적 도전 과제**:
1. **다양한 검색 방식 지원**
   - ISBN 검색
   - 제목/저자 검색
   - 베스트셀러, 신간 도서 추천

2. **데이터 구조 표준화**
   - API 응답 구조가 일관적이지 않음
   - 누락된 필드 처리

3. **에러 처리 및 폴백**
   - API 호출 실패 시 처리
   - 빈 결과 처리

**구현 코드**:
```javascript
// ISBN으로 책 검색
export const searchBookByISBN = async (isbn) => {
  const cleanISBN = isbn.replace(/-/g, '')
  
  const response = await fetch(
    `${GOOGLE_BOOKS_API_URL}?q=isbn:${cleanISBN}&key=${GOOGLE_BOOKS_API_KEY}`
  )
  
  if (!response.ok) {
    throw new Error(`API 요청 실패: ${response.status}`)
  }
  
  const data = await response.json()
  
  if (!data.items || data.items.length === 0) {
    throw new Error('해당 ISBN의 책을 찾을 수 없습니다.')
  }
  
  const book = data.items[0].volumeInfo
  
  // 표준화된 데이터 반환
  return {
    title: book.title || '',
    author: book.authors?.join(', ') || '',
    publisher: book.publisher || '',
    pageCount: book.pageCount || 0,
    thumbnail: book.imageLinks?.thumbnail || 
               book.imageLinks?.smallThumbnail || '',
    isbn13: book.industryIdentifiers?.find(id => id.type === 'ISBN_13')?.identifier || '',
    isbn10: book.industryIdentifiers?.find(id => id.type === 'ISBN_10')?.identifier || '',
    // ...
  }
}
```

**학습 내용**:
- RESTful API 통합 패턴
- 에러 핸들링 및 사용자 피드백
- 데이터 변환 및 표준화

### 8.4 커뮤니티 포스팅 필터링 및 검색 시스템

**구현 난이도**: ⭐⭐⭐

**기술적 도전 과제**:
1. **다중 조건 필터링**
   - 검색어, 정렬 옵션, 내 포스트 필터 동시 적용
   - 실시간 업데이트

2. **날짜 포맷팅**
   - 상대 시간 표시 ("3시간 전", "2일 전")
   - 정확한 시간 계산

**구현 코드**:
```javascript
// 날짜 포맷팅 함수
const formatDate = (dateString) => {
  const date = new Date(dateString)
  const now = new Date()
  const diff = now - date
  const minutes = Math.floor(diff / 60000)
  const hours = Math.floor(diff / 3600000)
  const days = Math.floor(diff / 86400000)
  
  if (minutes < 1) return '방금 전'
  if (minutes < 60) return `${minutes}분 전`
  if (hours < 24) return `${hours}시간 전`
  if (days < 7) return `${days}일 전`
  
  return date.toLocaleDateString('ko-KR')
}

// 다중 조건 필터링
useEffect(() => {
  let filtered = [...postings]
  
  // 내 포스트만 보기
  if (showMyPostsOnly && user) {
    filtered = filtered.filter(posting =>
      posting.authorId === user.id || posting.userId === user.id
    )
  }
  
  // 검색 필터 (제목, 저자, 내용, 태그)
  if (searchQuery.trim()) {
    const query = searchQuery.toLowerCase()
    filtered = filtered.filter(posting =>
      posting.title.toLowerCase().includes(query) ||
      posting.bookTitle.toLowerCase().includes(query) ||
      posting.bookAuthor.toLowerCase().includes(query) ||
      posting.content.toLowerCase().includes(query) ||
      posting.tags.some(tag => tag.toLowerCase().includes(query))
    )
  }
  
  // 정렬
  filtered.sort((a, b) => {
    switch (sortBy) {
      case 'rating':
        return b.rating - a.rating
      case 'oldest':
        return new Date(a.createdAt) - new Date(b.createdAt)
      case 'latest':
      default:
        return new Date(b.createdAt) - new Date(a.createdAt)
    }
  })
  
  setFilteredPostings(filtered)
}, [postings, searchQuery, sortBy, showMyPostsOnly, user])
```

**학습 내용**:
- 복잡한 필터링 로직 구현
- 성능 최적화 (메모이제이션)
- 사용자 친화적인 날짜 표시

---

## 9. 프로젝트 회고 및 개선 방향

### 9.1 잘된 점
1. **모듈화된 코드 구조**: 재사용 가능한 컴포넌트 설계
2. **사용자 경험**: 직관적인 UI/UX 설계
3. **에러 처리**: 적절한 에러 핸들링 및 사용자 피드백
4. **반응형 디자인**: 모바일, 태블릿, 데스크톱 지원

### 9.2 개선할 점
1. **백엔드 통합**: localStorage 대신 서버 기반 데이터 저장
2. **소셜 기능**: 댓글, 좋아요, 북마크 기능 추가
3. **독서 분석**: 그래프 및 통계 시각화 강화
4. **성능 최적화**: 코드 스플리팅, 이미지 최적화
5. **테스트**: 단위 테스트, 통합 테스트 추가

### 9.3 향후 계획
1. **PWA 구현**: 오프라인 지원 및 앱처럼 설치 가능
2. **소셜 로그인**: Google, Naver 소셜 로그인 구현
3. **AI 기반 추천**: 독서 취향 분석 및 책 추천
4. **모바일 앱**: React Native로 네이티브 앱 개발

---

## 10. 기술적 하이라이트

### 10.1 React 최신 기능 활용
- **React 19**: 최신 버전의 성능 개선 사항 활용
- **Hooks**: useState, useEffect, useContext, useRef 적극 활용
- **Context API**: 전역 상태 관리

### 10.2 최신 빌드 도구
- **Vite**: 빠른 개발 서버 및 빌드 속도
- **ES Modules**: 모던 JavaScript 모듈 시스템

### 10.3 API 통합
- **Google Books API**: 책 정보 검색 및 상세 정보
- **Kakao Map API**: 지도 및 위치 서비스
- **비동기 처리**: async/await 패턴 활용

### 10.4 상태 관리 전략
- **Local State**: 컴포넌트별 지역 상태
- **Global State**: Context API로 전역 상태
- **Persistent State**: localStorage로 영구 저장

---

## 11. 발표 요약

### 주요 성과
1. ✅ **완전한 독서 관리 시스템** 구현
2. ✅ **실시간 독서 타이머** 시스템 개발
3. ✅ **외부 API 통합** (Google Books, Kakao Map)
4. ✅ **사용자 친화적 UI/UX** 설계
5. ✅ **반응형 웹 애플리케이션** 구현

### 기술적 성취
- React 19 최신 기능 활용
- 복잡한 상태 관리 구현
- 비동기 API 통합 및 에러 처리
- 실시간 기능 구현
- 지도 API 통합

### 학습 내용
- React Hooks 고급 활용
- 외부 API 통합 패턴
- 상태 관리 전략
- 사용자 경험 최적화
- 에러 핸들링 및 디버깅

---

**감사합니다!**

**Q&A 시간**

